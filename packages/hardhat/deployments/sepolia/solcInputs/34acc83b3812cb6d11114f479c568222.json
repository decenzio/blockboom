{
  "language": "Solidity",
  "sources": {
    "contracts/Rankr.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\n/**\n * @title Rank5 Autonomous Game\n * @notice Repeated rounds game with {NUM_ITEMS} items and up to {MAX_PLAYERS} players per round.\n *         Each ranking submission requires exactly {ENTRY_FEE} wei. On reaching {MAX_PLAYERS} players:\n *           1) Compute cumulative ranking via Borda count\n *           2) Identify player(s) whose order matches the final order most closely\n *           3) Split and pay the prize pool among winners (first gets remainder)\n *           4) Reset state for the next round\n * @dev Functionality preserved; refactored with custom errors, modifiers, NatSpec and reentrancy guard.\n */\ncontract Rankr {\n    uint256 public constant ENTRY_FEE = 1e15; // 0.001 ETH\n    uint8   public constant NUM_ITEMS = 3;\n    uint8   public constant MAX_PLAYERS = 2;\n\n    enum Phase { CollectingItems, CollectingRanks }\n    Phase public phase = Phase.CollectingItems;\n\n    // --------- Errors ---------\n    error WrongPhase(Phase expected, Phase current);\n    error ItemsFull();\n    error InvalidItem();\n    error WrongEntryFee(uint256 provided);\n    error AlreadyRanked();\n    error IndexOutOfRange(uint8 index);\n    error DuplicateIndex(uint8 index);\n    error PayoutFailed(address to, uint256 amount);\n    error NoDirectETH();\n    error Reentrancy();\n\n    struct Item {\n        string author;\n        string title;\n        string url;\n        address adder;\n        uint256 addedAt;\n    }\n\n    struct ItemInput {\n        string author;\n        string title;\n        string url;\n    }\n\n    Item[NUM_ITEMS] public items;\n    uint8 public itemsCount;\n\n    address[] public players;\n    mapping(address => uint8[NUM_ITEMS]) private rankings;\n    mapping(address => bool) public hasRanked;\n\n    uint256 public prizePool;\n\n    // Reentrancy guard (lightweight)\n    bool private _entered;\n\n    event ItemAdded(uint8 indexed index, address indexed adder, uint256 addedAt, string author, string title, string url);\n    event RankingSubmitted(address indexed player, uint8[NUM_ITEMS] order);\n    event RoundCompleted(address[] winners, uint256 rewardPerWinner);\n    event RoundReset();\n\n    // --------- Modifiers ---------\n    modifier inPhase(Phase expected) {\n        if (phase != expected) revert WrongPhase(expected, phase);\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_entered) revert Reentrancy();\n        _entered = true;\n        _;\n        _entered = false;\n    }\n\n    // --------- External ---------\n\n    /// @notice Add an item with author, title and url until NUM_ITEMS exist, then switch to ranking phase.\n    /// @dev Reverts when not in CollectingItems phase, when items are full, or input is invalid.\n    /// @param item Author, title and url of the item to add.\n    function addItem(ItemInput calldata item) external inPhase(Phase.CollectingItems) {\n        if (itemsCount >= NUM_ITEMS) revert ItemsFull();\n        if (!_isValidItemInput(item)) revert InvalidItem();\n\n        items[itemsCount] = Item({ author: item.author, title: item.title, url: item.url, adder: msg.sender, addedAt: block.timestamp });\n        emit ItemAdded(itemsCount, msg.sender, block.timestamp, item.author, item.title, item.url);\n        itemsCount++;\n\n        if (itemsCount == NUM_ITEMS) phase = Phase.CollectingRanks;\n    }\n\n    /// @notice Submit ranking (bestâ†’worst) for the current round by paying exactly ENTRY_FEE wei.\n    /// @dev Reverts when not in CollectingRanks phase, wrong ETH value, or sender already ranked.\n    /// @param order A permutation of [0..NUM_ITEMS-1] from best to worst.\n    function rankItems(uint8[NUM_ITEMS] calldata order) external payable inPhase(Phase.CollectingRanks) nonReentrant {\n        if (msg.value != ENTRY_FEE) revert WrongEntryFee(msg.value);\n        if (hasRanked[msg.sender]) revert AlreadyRanked();\n        _validatePermutation(order);\n\n        players.push(msg.sender);\n        hasRanked[msg.sender] = true;\n        rankings[msg.sender] = order;\n        prizePool += msg.value;\n\n        emit RankingSubmitted(msg.sender, order);\n\n        if (players.length == MAX_PLAYERS) {\n            _finalizeRound();\n        }\n    }\n\n    // --------- View helpers ---------\n\n    /// @notice Returns the items proposed for the current round.\n    /// @return The fixed-size array of items of length NUM_ITEMS.\n    function getCurrentItems() external view returns (Item[NUM_ITEMS] memory) {\n        return items;\n    }\n\n    /// @notice Returns the addresses of players who have ranked in the current round so far.\n    /// @return The dynamic list of player addresses.\n    function getPlayers() external view returns (address[] memory) {\n        return players;\n    }\n\n    /// @notice Returns the current prize pool (in wei) accumulated for the round.\n    /// @return The prize pool balance.\n    function getPrizePool() external view returns (uint256) {\n        return prizePool;\n    }\n\n    // --------- Internal logic ---------\n\n    function _finalizeRound() internal {\n        // --- 1. Compute cumulative item scores (Borda count) ---\n        uint16[NUM_ITEMS] memory scores;\n        for (uint8 p = 0; p < MAX_PLAYERS; p++) {\n            uint8[NUM_ITEMS] memory order = rankings[players[p]];\n            for (uint8 pos = 0; pos < NUM_ITEMS; pos++) {\n                scores[order[pos]] += uint16(NUM_ITEMS - pos); // NUM_ITEMS..1 pts\n            }\n        }\n\n        // --- 2. Sort items by total score to get final order ---\n        uint8[NUM_ITEMS] memory finalOrder;\n        for (uint8 i = 0; i < NUM_ITEMS; i++) {\n            finalOrder[i] = i;\n        }\n        for (uint8 i = 0; i < NUM_ITEMS; i++) {\n            uint8 best = i;\n            for (uint8 j = i + 1; j < NUM_ITEMS; j++) {\n                if (scores[finalOrder[j]] > scores[finalOrder[best]]) best = j;\n            }\n            (finalOrder[i], finalOrder[best]) = (finalOrder[best], finalOrder[i]);\n        }\n\n        // --- 3. Score each player by how many positions match ---\n        uint8 maxMatch = 0;\n        address[] memory tmp = new address[](MAX_PLAYERS);\n        uint8 winCount = 0;\n\n        for (uint8 p = 0; p < MAX_PLAYERS; p++) {\n            uint8[NUM_ITEMS] memory ord = rankings[players[p]];\n            uint8 matches = 0;\n            for (uint8 k = 0; k < NUM_ITEMS; k++)\n                if (ord[k] == finalOrder[k]) matches++;\n\n            if (matches > maxMatch) {\n                maxMatch = matches;\n                winCount = 1;\n                tmp[0] = players[p];\n            } else if (matches == maxMatch) {\n                tmp[winCount++] = players[p];\n            }\n        }\n\n        // --- 4. Pay winners equally ---\n        address[] memory winners = new address[](winCount);\n        for (uint8 i = 0; i < winCount; i++) winners[i] = tmp[i];\n        uint256 poolBeforePayout = prizePool;\n        uint256 reward = poolBeforePayout / winCount;\n        uint256 totalBase = reward * winCount;\n        uint256 remainder = poolBeforePayout - totalBase;\n        prizePool = 0; // CEI: zero before external calls\n\n        for (uint8 i = 0; i < winCount; i++) {\n            uint256 amount = reward + (i == 0 ? remainder : 0);\n            (bool ok, ) = winners[i].call{value: amount}(\"\");\n            if (!ok) revert PayoutFailed(winners[i], amount);\n        }\n\n        emit RoundCompleted(winners, reward);\n\n        // --- 5. Reset state for next round ---\n        _resetState();\n    }\n\n    function _resetState() internal {\n        for (uint8 i = 0; i < NUM_ITEMS; i++) {\n            items[i] = Item({ author: \"\", title: \"\", url: \"\", adder: address(0), addedAt: 0 });\n        }\n        itemsCount = 0;\n\n        for (uint8 i = 0; i < players.length; i++) {\n            delete hasRanked[players[i]];\n            delete rankings[players[i]];\n        }\n        delete players;\n        prizePool = 0;\n        phase = Phase.CollectingItems;\n\n        emit RoundReset();\n    }\n\n    // --------- Utils ---------\n\n    function _isValidItemInput(ItemInput calldata item) internal pure returns (bool) {\n        if (bytes(item.author).length == 0) return false;\n        if (bytes(item.title).length == 0) return false;\n        if (bytes(item.url).length == 0) return false;\n        return true;\n    }\n\n    function _validatePermutation(uint8[NUM_ITEMS] calldata order) internal pure {\n        bool[NUM_ITEMS] memory seen;\n        for (uint8 i = 0; i < NUM_ITEMS; i++) {\n            uint8 v = order[i];\n            if (v >= NUM_ITEMS) revert IndexOutOfRange(v);\n            if (seen[v]) revert DuplicateIndex(v);\n            seen[v] = true;\n        }\n    }\n\n    /// @dev No direct ETH transfers accepted.\n    receive() external payable { revert NoDirectETH(); }\n\n    /// @dev No function selectors supported; reject unknown calls and ETH via fallback path.\n    fallback() external payable { revert NoDirectETH(); }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}