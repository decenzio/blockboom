{
  "language": "Solidity",
  "sources": {
    "contracts/Rank5Game.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\n/**\n * @title Rank5 Autonomous Game\n * @notice 5 items, 10 players. Each ranking costs 0.001 ETH.\n *         When 10th player submits, contract:\n *           1) Calculates cumulative ranking (Borda count)\n *           2) Finds player(s) closest to final order\n *           3) Splits and pays prize pool\n *           4) Resets for next round\n */\ncontract Rank5Game {\n    uint256 public constant ENTRY_FEE = 1e15; // 0.001 ETH\n    uint8   public constant NUM_ITEMS = 3;\n    uint8   public constant MAX_PLAYERS = 2;\n\n    enum Phase { CollectingItems, CollectingRanks }\n    Phase public phase = Phase.CollectingItems;\n\n    struct Item {\n        string author;\n        string title;\n        string url;\n        address adder;\n        uint256 addedAt;\n    }\n\n    struct ItemInput {\n        string author;\n        string title;\n        string url;\n    }\n\n    Item[NUM_ITEMS] public items;\n    uint8 public itemsCount;\n\n    address[] public players;\n    mapping(address => uint8[NUM_ITEMS]) private rankings;\n    mapping(address => bool) public hasRanked;\n\n    uint256 public prizePool;\n\n    event ItemAdded(uint8 indexed index, address indexed adder, uint256 addedAt, string author, string title, string url);\n    event RankingSubmitted(address indexed player, uint8[NUM_ITEMS] order);\n    event RoundCompleted(address[] winners, uint256 rewardPerWinner);\n    event RoundReset();\n\n    // --------- External ---------\n\n    /// @notice Add an item with author, title and url until NUM_ITEMS exist, then switch to ranking phase\n    function addItem(ItemInput calldata item) external {\n        require(phase == Phase.CollectingItems, \"not item phase\");\n        require(itemsCount < NUM_ITEMS, \"items full\");\n        require(_isValidItemInput(item), \"invalid item\");\n\n        items[itemsCount] = Item({ author: item.author, title: item.title, url: item.url, adder: msg.sender, addedAt: block.timestamp });\n        emit ItemAdded(itemsCount, msg.sender, block.timestamp, item.author, item.title, item.url);\n        itemsCount++;\n\n        if (itemsCount == NUM_ITEMS) phase = Phase.CollectingRanks;\n    }\n\n    /// @notice Submit ranking (bestâ†’worst), costs 0.001 ETH\n    function rankItems(uint8[NUM_ITEMS] calldata order) external payable {\n        require(phase == Phase.CollectingRanks, \"not ranking phase\");\n        require(msg.value == ENTRY_FEE, \"need 0.001 ETH\");\n        require(!hasRanked[msg.sender], \"already ranked\");\n        _validatePermutation(order);\n\n        players.push(msg.sender);\n        hasRanked[msg.sender] = true;\n        rankings[msg.sender] = order;\n        prizePool += msg.value;\n\n        emit RankingSubmitted(msg.sender, order);\n\n        if (players.length == MAX_PLAYERS) {\n            _finalizeRound();\n        }\n    }\n\n    // --------- View helpers ---------\n\n    function getCurrentItems() external view returns (Item[NUM_ITEMS] memory) {\n        return items;\n    }\n\n    function getPlayers() external view returns (address[] memory) {\n        return players;\n    }\n\n    function getPrizePool() external view returns (uint256) {\n        return prizePool;\n    }\n\n    // --------- Internal logic ---------\n\n    function _finalizeRound() internal {\n        // --- 1. Compute cumulative item scores (Borda count) ---\n        uint16[NUM_ITEMS] memory scores;\n        for (uint8 p = 0; p < MAX_PLAYERS; p++) {\n            uint8[NUM_ITEMS] memory order = rankings[players[p]];\n            for (uint8 pos = 0; pos < NUM_ITEMS; pos++) {\n                scores[order[pos]] += uint16(NUM_ITEMS - pos); // NUM_ITEMS..1 pts\n            }\n        }\n\n        // --- 2. Sort items by total score to get final order ---\n        uint8[NUM_ITEMS] memory finalOrder;\n        for (uint8 i = 0; i < NUM_ITEMS; i++) {\n            finalOrder[i] = i;\n        }\n        for (uint8 i = 0; i < NUM_ITEMS; i++) {\n            uint8 best = i;\n            for (uint8 j = i + 1; j < NUM_ITEMS; j++) {\n                if (scores[finalOrder[j]] > scores[finalOrder[best]]) best = j;\n            }\n            (finalOrder[i], finalOrder[best]) = (finalOrder[best], finalOrder[i]);\n        }\n\n        // --- 3. Score each player by how many positions match ---\n        uint8 maxMatch = 0;\n        address[] memory tmp = new address[](MAX_PLAYERS);\n        uint8 winCount = 0;\n\n        for (uint8 p = 0; p < MAX_PLAYERS; p++) {\n            uint8[NUM_ITEMS] memory ord = rankings[players[p]];\n            uint8 matches = 0;\n            for (uint8 k = 0; k < NUM_ITEMS; k++)\n                if (ord[k] == finalOrder[k]) matches++;\n\n            if (matches > maxMatch) {\n                maxMatch = matches;\n                winCount = 1;\n                tmp[0] = players[p];\n            } else if (matches == maxMatch) {\n                tmp[winCount++] = players[p];\n            }\n        }\n\n        // --- 4. Pay winners equally ---\n        address[] memory winners = new address[](winCount);\n        for (uint8 i = 0; i < winCount; i++) winners[i] = tmp[i];\n        uint256 poolBeforePayout = prizePool;\n        uint256 reward = poolBeforePayout / winCount;\n        uint256 totalBase = reward * winCount;\n        uint256 remainder = poolBeforePayout - totalBase;\n        prizePool = 0; // CEI: zero before external calls\n\n        for (uint8 i = 0; i < winCount; i++) {\n            uint256 amount = reward + (i == 0 ? remainder : 0);\n            (bool ok, ) = winners[i].call{value: amount}(\"\");\n            require(ok, \"payout failed\");\n        }\n\n        emit RoundCompleted(winners, reward);\n\n        // --- 5. Reset state for next round ---\n        _resetState();\n    }\n\n    function _resetState() internal {\n        for (uint8 i = 0; i < NUM_ITEMS; i++) {\n            items[i] = Item({ author: \"\", title: \"\", url: \"\", adder: address(0), addedAt: 0 });\n        }\n        itemsCount = 0;\n\n        for (uint8 i = 0; i < players.length; i++) {\n            delete hasRanked[players[i]];\n            delete rankings[players[i]];\n        }\n        delete players;\n        prizePool = 0;\n        phase = Phase.CollectingItems;\n\n        emit RoundReset();\n    }\n\n    // --------- Utils ---------\n\n    function _isValidItemInput(ItemInput calldata item) internal pure returns (bool) {\n        if (bytes(item.author).length == 0) return false;\n        if (bytes(item.title).length == 0) return false;\n        if (bytes(item.url).length == 0) return false;\n        return true;\n    }\n\n    function _validatePermutation(uint8[NUM_ITEMS] calldata order) internal pure {\n        bool[NUM_ITEMS] memory seen;\n        for (uint8 i = 0; i < NUM_ITEMS; i++) {\n            uint8 v = order[i];\n            require(v < NUM_ITEMS, \"index out of range\");\n            require(!seen[v], \"duplicate\");\n            seen[v] = true;\n        }\n    }\n\n    receive() external payable { revert(\"no direct ETH\"); }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}